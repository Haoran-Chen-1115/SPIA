diff -urpN src/base.F ../vasp.5.4.4/src/base.F
--- src/base.F	2017-04-20 17:03:55.000000000 +0800
+++ ../vasp.5.4.4/src/base.F	2022-09-18 10:46:24.881730674 +0800
@@ -95,6 +95,22 @@
 ! characters allways last
         CHARACTER*40 SZNAM1          ! header of INCAR
         CHARACTER*6  SZPREC          ! precision information
+! ---------------------------------------------------------------------
+        LOGICAL LFIXCOM
+! obtain the full Hamilton matrix
+        LOGICAL LFHAM
+        LOGICAL LSMAL
+        INTEGER NCUT
+        INTEGER NTEST
+        INTEGER KOMEGA
+        REAL(q) TEMP
+        INTEGER NB
+        LOGICAL LINDEX
+        LOGICAL LCLOSE
+        INTEGER NCONT
+        INTEGER NJUMP
+        LOGICAL LKPOINTS
+! ---------------------------------------------------------------------
       END TYPE
 
       TYPE in_struct
diff -urpN src/bext.F ../vasp.5.4.4/src/bext.F
--- src/bext.F	2017-04-20 17:03:55.000000000 +0800
+++ ../vasp.5.4.4/src/bext.F	2022-04-03 15:27:25.947346021 +0800
@@ -39,6 +39,8 @@
       INTEGER       :: ISPIN,NREQ
       LOGICAL       :: LSORBIT,LNONCOLLINEAR
 
+      REAL(q),PARAMETER :: BOHRMOM_EV=5.7883818012E-5_q
+
       LOPEN=.FALSE.
       OPEN(UNIT=IU5,FILE=INCAR,STATUS='OLD')
 
@@ -91,11 +93,12 @@
                WRITE(IU0,*)'Error reading item ''BEXT'' from file INCAR.'
             BEXT=0
          ENDIF
+         BEXT = BEXT*BOHRMOM_EV
 
          CALL XML_INCAR_V('BEXT','F',IDUM,BEXT,CDUM,LDUM,CHARAC,N)
 
          BNORM2=BEXT(1)*BEXT(1)+BEXT(2)*BEXT(2)+BEXT(3)*BEXT(3)
-         IF (BNORM2>1.E-6_q) THEN
+         IF (sqrt(BNORM2)>1.E-6_q) THEN
             LBEXT=.TRUE.
          ENDIF
       ENDIF
diff -urpN src/chgloc.F ../vasp.5.4.4/src/chgloc.F
--- src/chgloc.F	2017-04-20 17:03:55.000000000 +0800
+++ ../vasp.5.4.4/src/chgloc.F	2022-04-03 15:27:25.943345973 +0800
@@ -14,6 +14,6 @@
       IMPLICIT REAL(q) (A-H,O-Z)
       DIMENSION PAR(NBANDS,NKDIM,LDIMP,NIONS,ISPIN)
       DIMENSION FERWE(NBANDS,NKDIM,ISPIN)
-
+      
       RETURN
       END
diff -urpN src/dynconstr.F ../vasp.5.4.4/src/dynconstr.F
--- src/dynconstr.F	2017-04-20 17:03:56.000000000 +0800
+++ ../vasp.5.4.4/src/dynconstr.F	2022-09-18 10:45:52.757370589 +0800
@@ -1709,6 +1709,11 @@
           REAL(q),SAVE :: EPOT_old
           REAL(q) :: hspring_R0(iconst8),hspring_K(iconst8),hspring_force(iconst8)
           
+          !--------------------------
+          REAL(q) :: CMASS(3,1)
+          REAL(q) :: VEL_out(3,T_INFO%NIONS)
+          INTEGER :: N
+          !--------------------------
          
  72     FORMAT( ' POSITION    ',35X,'REST-FORCE (eV/Angst)'/ &
      &          ' ----------------------------------------------', &
@@ -1841,9 +1846,22 @@
 
           !c compute position of c. of mass for the slice t:
           CALL GIVE_CMASS(T_INFO,DYN%POSIOC,CMASS1)
+          !---------------------------------------------------- 
+          IF (INFO%LFIXCOM) THEN
+              ! Force to fix the center of mass
+              CALL GIVE_CMASS(T_INFO,DYN%VEL,CMASS)
+          ELSE
+              CMASS=0._q
+          ENDIF
+          !---------------------------------------------------- 
 
           !c r(t+dt)=r(t)+v'(t+dt)*dt
-          DYN%POSION=DYN%POSIOC+DYN%VEL
+          !DYN%POSION=DYN%POSIOC+DYN%VEL
+          DO i=1,T_INFO%NIONS
+            DO j=1,3
+             DYN%POSION(j,i)=DYN%POSIOC(j,i)+DYN%VEL(j,i)-CMASS(j,1)
+            ENDDO
+          ENDDO
 
           
           ECONST=0._q
diff -urpN src/electron.F ../vasp.5.4.4/src/electron.F
--- src/electron.F	2017-04-20 17:03:56.000000000 +0800
+++ ../vasp.5.4.4/src/electron.F	2022-04-03 15:27:25.955346119 +0800
@@ -605,6 +605,26 @@
           INFO%LOVERL,LMDIM,CQIJ, LDIMP, LDIMP,LMDIMP,.FALSE., IO%LORBIT, PAR, &
           EFERMI, KPOINTS%EMIN, KPOINTS%EMAX)
       ENDIF
+
+! ---------------------------------- FHAM --------------------------------
+! ========================================================================
+! If the end of the electronic loop is reached
+! calculate the full hamiltonian matrix (i.e. FHAM)
+! if required
+! ========================================================================
+
+      IF (INFO%LABORT .AND. INFO%LFHAM) THEN
+          IF (LABORT_WITHOUT_CONV) THEN
+              WRITE(*,*) 'not converged, full hamiltonian not calculated'
+          ELSE
+              CALL OUT_HAM(GRID, NONL_S, P, WDES, LATT_CUR, T_INFO, INFO, SV,&
+                        LMDIM, CDIJ, CQIJ,HAMILTONIAN ,EFERMI, TOTEN,NSTEP,DYN)
+          ENDIF
+      ENDIF
+
+! ------------------------------------------------------------------------
+
+
 ! ======================================================================
 ! If the end of the electronic loop is reached
 ! calculate accurate initial state core level shifts
diff -urpN src/electron_gpu.F ../vasp.5.4.4/src/electron_gpu.F
--- src/electron_gpu.F	2017-04-20 17:03:56.000000000 +0800
+++ ../vasp.5.4.4/src/electron_gpu.F	2022-04-03 15:27:25.951346071 +0800
@@ -656,6 +656,25 @@
          DEALLOCATE(PAR_DUMMY)
       ENDIF
 
+! ---------------------------------- FHAM --------------------------------
+! ========================================================================
+! If the end of the electronic loop is reached
+! calculate the full hamiltonian matrix (i.e. FHAM)
+! if required
+! ========================================================================
+
+      IF (INFO%LABORT .AND. INFO%LFHAM) THEN
+          IF (LABORT_WITHOUT_CONV) THEN
+              WRITE(*,*) 'not converged, full hamiltonian not calculated'
+          ELSE
+              CALL OUT_HAM(GRID, NONL_S, P, WDES, LATT_CUR, T_INFO, INFO, SV,&
+                        LMDIM, CDIJ, CQIJ,HAMILTONIAN ,EFERMI, TOTEN,NSTEP,DYN)
+          ENDIF
+      ENDIF
+
+! ------------------------------------------------------------------------
+
+
 ! ======================================================================
 ! If the end of the electronic loop is reached
 ! calculate accurate initial state core level shifts
diff -urpN src/fsockets.f90 ../vasp.5.4.4/src/fsockets.f90
--- src/fsockets.f90	1970-01-01 08:00:00.000000000 +0800
+++ ../vasp.5.4.4/src/fsockets.f90	2022-04-03 16:45:21.180600198 +0800
@@ -0,0 +1,202 @@
+!F90 ISO_C_BINGING wrapper for socket communication.
+
+!Copyright (C) 2013, Michele Ceriotti
+
+!Permission is hereby granted, free of charge, to any person obtaining
+!a copy of this software and associated documentation files (the
+!"Software"), to deal in the Software without restriction, including
+!without limitation the rights to use, copy, modify, merge, publish,
+!distribute, sublicense, and/or sell copies of the Software, and to
+!permit persons to whom the Software is furnished to do so, subject to
+!the following conditions:
+
+!The above copyright notice and this permission notice shall be included
+!in all copies or substantial portions of the Software.
+
+!THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+!EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+!MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+!IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+!CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+!TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+!SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+!Contains both the functions that transmit data to the socket and read the data
+!back out again once finished, and the function which opens the socket initially.
+
+!Functions:
+!   open_socket: Opens a socket with the required host server, socket type and
+!      port number.
+!   write_buffer: Writes a string to the socket.
+!   read_buffer: Reads data from the socket.
+
+   MODULE F90SOCKETS
+   USE ISO_C_BINDING
+   
+   IMPLICIT NONE
+
+  INTERFACE writebuffer
+      MODULE PROCEDURE writebuffer_s, &
+                       writebuffer_d, writebuffer_dv, &
+                       writebuffer_i
+                       
+  END INTERFACE 
+
+  INTERFACE readbuffer
+      MODULE PROCEDURE readbuffer_s, &
+                       readbuffer_dv, readbuffer_d, &
+                       readbuffer_i
+                       
+  END INTERFACE 
+
+  INTERFACE
+    SUBROUTINE open_csocket(psockfd, inet, port, host) BIND(C, name="open_socket")
+      USE ISO_C_BINDING
+    INTEGER(KIND=C_INT)                      :: psockfd, inet, port
+    CHARACTER(KIND=C_CHAR), DIMENSION(*)     :: host
+
+    END SUBROUTINE open_csocket
+
+    
+    SUBROUTINE writebuffer_csocket(psockfd, pdata, plen) BIND(C, name="writebuffer")
+      USE ISO_C_BINDING
+    INTEGER(KIND=C_INT)                      :: psockfd
+    TYPE(C_PTR), VALUE                       :: pdata
+    INTEGER(KIND=C_INT)                      :: plen
+
+    END SUBROUTINE writebuffer_csocket       
+
+    SUBROUTINE readbuffer_csocket(psockfd, pdata, plen) BIND(C, name="readbuffer")
+      USE ISO_C_BINDING
+    INTEGER(KIND=C_INT)                      :: psockfd
+    TYPE(C_PTR), VALUE                       :: pdata
+    INTEGER(KIND=C_INT)                      :: plen
+
+    END SUBROUTINE readbuffer_csocket   
+  END INTERFACE
+
+   CONTAINS
+   
+   SUBROUTINE open_socket(psockfd, inet, port, host)      
+      IMPLICIT NONE
+      INTEGER, INTENT(IN) :: inet, port
+      INTEGER, INTENT(OUT) :: psockfd
+      CHARACTER(LEN=*), INTENT(IN) :: host
+      CHARACTER(LEN=1,KIND=C_CHAR) :: chost(1024)
+
+      CALL fstr2cstr(host, chost)
+      CALL open_csocket(psockfd, inet, port, host)
+   END SUBROUTINE
+
+   SUBROUTINE fstr2cstr(fstr, cstr, plen)
+      IMPLICIT NONE
+      CHARACTER(LEN=*), INTENT(IN) :: fstr
+      CHARACTER(LEN=1,KIND=C_CHAR), INTENT(OUT) :: cstr(:)
+      INTEGER, INTENT(IN), OPTIONAL :: plen
+      
+      INTEGER i,n
+      IF (PRESENT(plen)) THEN
+         n = plen
+         DO i=1,n
+            cstr(i) = fstr(i:i)
+         ENDDO
+      ELSE
+         n = LEN_TRIM(fstr)
+         DO i=1,n
+            cstr(i) = fstr(i:i)
+         ENDDO
+         cstr(n+1) = C_NULL_CHAR
+      END IF
+   END SUBROUTINE
+
+  SUBROUTINE writebuffer_d (psockfd, fdata)
+      USE ISO_C_BINDING
+    INTEGER, INTENT(IN)                      :: psockfd
+    REAL(KIND=8), INTENT(IN)                :: fdata
+
+    REAL(KIND=C_DOUBLE), TARGET              :: cdata
+
+      cdata = fdata
+      CALL writebuffer_csocket(psockfd, c_loc(cdata), 8)
+  END SUBROUTINE
+
+  SUBROUTINE writebuffer_i (psockfd, fdata)
+      USE ISO_C_BINDING
+    INTEGER, INTENT(IN)                      :: psockfd, fdata
+
+    INTEGER(KIND=C_INT), TARGET              :: cdata
+
+      cdata = fdata
+      CALL writebuffer_csocket(psockfd, c_loc(cdata), 4)
+  END SUBROUTINE
+
+  SUBROUTINE writebuffer_s (psockfd, fstring, plen)
+      USE ISO_C_BINDING
+    INTEGER, INTENT(IN)                      :: psockfd
+    CHARACTER(LEN=*), INTENT(IN)             :: fstring
+    INTEGER, INTENT(IN)                      :: plen
+
+    INTEGER                                  :: i
+    CHARACTER(LEN=1, KIND=C_CHAR), TARGET    :: cstring(plen)
+
+      DO i = 1,plen
+         cstring(i) = fstring(i:i)
+      ENDDO
+      CALL writebuffer_csocket(psockfd, c_loc(cstring(1)), plen)
+  END SUBROUTINE
+
+  SUBROUTINE writebuffer_dv(psockfd, fdata, plen)
+      USE ISO_C_BINDING  
+    INTEGER, INTENT(IN)                      :: psockfd, plen
+    REAL(KIND=8), INTENT(IN), TARGET        :: fdata(plen)
+
+      CALL writebuffer_csocket(psockfd, c_loc(fdata(1)), 8*plen)
+  END SUBROUTINE
+
+  SUBROUTINE readbuffer_d (psockfd, fdata)
+      USE ISO_C_BINDING
+    INTEGER, INTENT(IN)                      :: psockfd
+    REAL(KIND=8), INTENT(OUT)               :: fdata
+
+    REAL(KIND=C_DOUBLE), TARGET              :: cdata
+
+      CALL readbuffer_csocket(psockfd, c_loc(cdata), 8)
+      fdata=cdata
+  END SUBROUTINE
+
+  SUBROUTINE readbuffer_i (psockfd, fdata)
+      USE ISO_C_BINDING
+    INTEGER, INTENT(IN)                      :: psockfd
+    INTEGER, INTENT(OUT)                     :: fdata
+
+    INTEGER(KIND=C_INT), TARGET              :: cdata
+
+      CALL readbuffer_csocket(psockfd, c_loc(cdata), 4)
+      fdata = cdata
+  END SUBROUTINE
+
+  SUBROUTINE readbuffer_s (psockfd, fstring, plen)
+      USE ISO_C_BINDING
+    INTEGER, INTENT(IN)                      :: psockfd
+    CHARACTER(LEN=*), INTENT(OUT)            :: fstring
+    INTEGER, INTENT(IN)                      :: plen
+
+    INTEGER                                  :: i
+    CHARACTER(LEN=1, KIND=C_CHAR), TARGET    :: cstring(plen)
+
+      CALL readbuffer_csocket(psockfd, c_loc(cstring(1)), plen)
+      fstring=""   
+      DO i = 1,plen
+         fstring(i:i) = cstring(i)
+      ENDDO
+  END SUBROUTINE
+
+  SUBROUTINE readbuffer_dv(psockfd, fdata, plen)
+      USE ISO_C_BINDING  
+    INTEGER, INTENT(IN)                      :: psockfd, plen
+    REAL(KIND=8), INTENT(OUT), TARGET       :: fdata(plen)
+
+      CALL readbuffer_csocket(psockfd, c_loc(fdata(1)), 8*plen)
+  END SUBROUTINE
+  END MODULE
diff -urpN src/main.F ../vasp.5.4.4/src/main.F
--- src/main.F	2017-04-20 17:03:58.000000000 +0800
+++ ../vasp.5.4.4/src/main.F	2022-09-18 10:51:37.169247918 +0800
@@ -142,6 +142,8 @@
       USE mkproj
       USE classicfields
       USE rpa_force
+      ! ipi socket module
+      USE F90SOCKETS, ONLY : open_socket, writebuffer, readbuffer
 ! Thomas Bucko's code contributions
 #ifdef tbdyn
       USE random_seeded
@@ -256,6 +258,23 @@
       INTEGER :: TIU6, TIU0
       INTEGER :: ISPECIAL=0         ! allows to select special undocumented features
       INTEGER :: MDALGO=0           ! dublicates MDALGO in tbdyn
+      
+      ! ipi socket variables
+      INTEGER, PARAMETER :: MSGLEN=12 ! length of headers of driver/wrapper commun. protocol
+      INTEGER :: SOCKET, PORT       ! socket ID, port
+      INTEGER :: INET               ! socket mode: 0 = unix, 1 = inet
+      CHARACTER(LEN=1024) :: IHOST  ! address of the server
+      CHARACTER(LEN=12) :: HEADER   ! socket communication buffers
+      INTEGER :: IMSG               ! 1 status, 2 posdata, 3 getforce, 4 other
+      LOGICAL :: HASDATA
+      ! ipi variables for the system
+      INTEGER :: NAT
+      REAL(q) :: IPIPOT
+      REAL(q), ALLOCATABLE :: IPIATOMS(:), IPIFORCES(:)
+      REAL(q) :: CELL_H(9), CELL_IH(9), VIRIAL(9)
+      ! unit conversion
+      REAL(q) :: EVTOHA, FOCTOAU
+
 !=======================================================================
 !  begin array dimensions ...
 !=======================================================================
@@ -391,6 +410,11 @@
 !  initialise / set constants and parameters ...
 !=======================================================================
 
+      ! ipi initialize variables
+      EVTOHA = 1_q/(2_q*RYTOEV)
+      FOCTOAU = AUTOA*EVTOHA
+      HASDATA = .FALSE.
+
 #ifdef libbeef
       LBEEFCALCBASIS = .FALSE.
 #endif
@@ -571,7 +595,11 @@
           WDES%LNONCOLLINEAR,WDES%LSORBIT,WDES%SAXIS,INFO%LMETAGGA, &
           WDES%LSPIRAL,WDES%LZEROZ,WDES%QSPIRAL,WDES%LORBITALREAL, &
           INFO%LASPH,INFO%TURBO,INFO%IRESTART,INFO%NREBOOT,INFO%NMIN,INFO%EREF, &
-          INFO%NLSPLINE,ISPECIAL,MDALGO &
+          INFO%NLSPLINE,ISPECIAL,MDALGO, &
+          INFO%LFIXCOM, &
+          INFO%LFHAM,INFO%NCUT,INFO%NTEST,INFO%LSMAL,INFO%KOMEGA,INFO%TEMP,&
+          INFO%NB,INFO%LINDEX,INFO%LCLOSE,INFO%NCONT,INFO%LKPOINTS,INFO%NJUMP &
+         ,IHOST,PORT,INET &
 #ifdef libbeef
          ,LBEEFENS,LBEEFBAS &
 #endif
@@ -671,6 +699,7 @@
      &                 ITUT,1,CDUM,1,LDUM,1,IO%IU0,IO%IDIOT)
       END IF
 #endif
+
 !-----------------------------------------------------------------------
 ! core level shift related items (parses INCAR)
 !-----------------------------------------------------------------------
@@ -820,6 +849,95 @@
 !xml finish copying parameters from INCAR to xml file
 ! no INCAR reading from here 
       CALL XML_CLOSE_TAG("incar")
+
+!-----------------------------------------------------------------------
+! ipi open socket
+!-----------------------------------------------------------------------
+#ifdef MPI
+      IF (DYN%IBRION==23) THEN
+        IF (COMM%NODE_ME == 1) THEN
+          WRITE(TIU0,*) " DRIVER - Connecting to host ", TRIM(IHOST)
+          IF (INET > 0) THEN
+            WRITE(TIU0,*) " on port ", PORT, " using an internet socket."
+          ELSE
+            WRITE(TIU0,*) " using UNIX socket."
+          ENDIF
+          CALL open_socket(SOCKET, INET, PORT, TRIM(IHOST))
+          WRITE(TIU0,*) "VASP ipi driver (written by Wei Fang) successfully starting"
+        ENDIF
+        ! get initial geometries from ipi
+      driver_init: DO
+        ! do communication on master node only
+        IF (COMM%NODE_ME == 1) THEN
+          CALL readbuffer(SOCKET, HEADER, MSGLEN)
+          IF (TRIM(HEADER) == "STATUS") THEN
+            IMSG=1
+          ELSE IF (TRIM(HEADER) == "POSDATA") THEN
+            IMSG=2
+          ELSE
+            IMSG=4
+          ENDIF
+        ENDIF
+        CALL M_bcast_i(COMM,IMSG,1)
+        IF (COMM%NODE_ME == 1) WRITE(TIU0,*) " @ DRIVER MODE: Message from server: ", TRIM(HEADER)
+        IF (IMSG == 1) THEN
+          IF (COMM%NODE_ME == 1) THEN  ! does not need init
+            CALL writebuffer(SOCKET, "READY       ", MSGLEN)
+          ENDIF
+        ELSE IF (IMSG == 2) THEN
+          ! receives the positions & the cell data
+          IF (COMM%NODE_ME == 1) THEN    ! first the cell and the number of atoms
+            CALL readbuffer(SOCKET, CELL_H, 9)
+            CALL readbuffer(SOCKET, CELL_IH, 9)
+            CALL readbuffer(SOCKET, NAT)
+          ENDIF
+          ! broadcast to all nodes
+          CALL M_bcast_d(COMM,CELL_H,9)
+          CALL M_bcast_d(COMM,CELL_IH,9)
+          CALL M_bcast_i(COMM,NAT,1)
+          ! convert to vasp LATT_CUR%A & %B format & units conversion
+          DO NI=1,3
+            LATT_CUR%A(NI,1) = CELL_H(NI*3-2)*AUTOA
+            LATT_CUR%A(NI,2) = CELL_H(NI*3-1)*AUTOA
+            LATT_CUR%A(NI,3) = CELL_H(NI*3)*AUTOA
+          ENDDO
+          DO NI=1,3
+            LATT_CUR%B(NI,1) = CELL_IH(NI*3-2)/AUTOA
+            LATT_CUR%B(NI,2) = CELL_IH(NI*3-1)/AUTOA
+            LATT_CUR%B(NI,3) = CELL_IH(NI*3)/AUTOA
+          ENDDO
+          CALL LATTIC(LATT_CUR)
+ 2333     FORMAT(' @DRIVER MODE: Received direct lattice vectors',17X,'reciprocal lattice vectors'/ &
+       &   3(2(3X,3F13.9)/) /)
+          IF (COMM%NODE_ME == 1) THEN
+            WRITE(TIU0,*) " @ DRIVER MODE: Received initial lattice "
+            WRITE(TIU6,2333) ((LATT_CUR%A(I,J),I=1,3),(LATT_CUR%B(I,J),I=1,3),J=1,3)
+          ENDIF
+          ! then we can allocate the buffer for the positions, and receive them
+          ALLOCATE(IPIATOMS(3*NAT))
+          ALLOCATE(IPIFORCES(3*NAT))
+          IF (COMM%NODE_ME == 1) CALL readbuffer(SOCKET, IPIATOMS, NAT*3)
+          CALL M_bcast_d(COMM,IPIATOMS,NAT*3) ! and broadcast them to all nodes
+          ! convert to vasp DYN%POSION format & units conversion
+          DO NI=1,NAT
+            DYN%POSION(1,NI) = IPIATOMS(NI*3-2)*AUTOA
+            DYN%POSION(2,NI) = IPIATOMS(NI*3-1)*AUTOA
+            DYN%POSION(3,NI) = IPIATOMS(NI*3)*AUTOA
+          ENDDO
+          CALL KARDIR(NAT,DYN%POSION,LATT_CUR%B)
+          CALL TOPRIM(NAT,DYN%POSION)
+          DYN%POSIOC=DYN%POSION
+          IF (COMM%NODE_ME == 1) WRITE(TIU0,*) " @ DRIVER MODE: Received initial positions "
+          EXIT driver_init
+        ELSE
+          INFO%LSTOP=.TRUE.
+          IF (COMM%NODE_ME == 1) WRITE(TIU0,*) "EXIT driver or unknow msg received"
+          EXIT driver_init
+        ENDIF
+      ENDDO driver_init
+      ENDIF
+#endif
+
 !-----------------------------------------------------------------------
 #if CUDA_GPU
       CALL GPU_TEST(INFO,NPAR,IO)
@@ -3191,7 +3309,7 @@ io_end
       ENDIF
 
       IF (DYN%IBRION==-1 .OR. DYN%IBRION==5 .OR. DYN%IBRION==6 .OR. &
-           DYN%IBRION==7.OR.DYN%IBRION==8) THEN
+           DYN%IBRION==7.OR.DYN%IBRION==8 .OR. DYN%IBRION==23) THEN
          EENTROPY=E%EENTROPY*SCALEE
          io_begin
          WRITE(17 ,7281,ADVANCE='NO') NSTEP,TOTEN, &
@@ -3366,6 +3484,112 @@ ibrion: IF (DYN%IBRION==0) THEN
 
 !=======================================================================
 ! DYN%IBRION =
+! 23  driver mode for ipi
+!=======================================================================
+#ifdef MPI
+      ELSE IF (DYN%IBRION==23) THEN
+        DYN%POSIOC=DYN%POSION
+        HASDATA=.TRUE.
+
+      driver_loop: DO
+        ! do communication on master node only
+        IF (COMM%NODE_ME == 1) THEN
+          CALL readbuffer(SOCKET, HEADER, MSGLEN)
+          IF (TRIM(HEADER) == "STATUS") THEN
+            IMSG=1
+          ELSE IF (TRIM(HEADER) == "POSDATA") THEN
+            IMSG=2
+          ELSE IF (TRIM(HEADER) == "GETFORCE") THEN
+            IMSG=3
+          ELSE
+            IMSG=4
+          ENDIF
+        ENDIF
+        CALL M_bcast_i(COMM,IMSG,1)
+        IF (COMM%NODE_ME == 1) WRITE(TIU0,*) " @ DRIVER MODE: Message from server: ", TRIM(HEADER)
+        IF (IMSG == 1) THEN
+          IF (COMM%NODE_ME == 1) THEN
+            IF (HASDATA) THEN
+              CALL writebuffer(SOCKET,"HAVEDATA    ",MSGLEN)
+            ELSE
+              CALL writebuffer(SOCKET,"READY       ",MSGLEN)
+            ENDIF
+          ENDIF
+        ELSE IF (IMSG == 2) THEN
+          ! receives cell data
+          IF (COMM%NODE_ME == 1) THEN
+            CALL readbuffer(SOCKET, CELL_H, 9)
+            CALL readbuffer(SOCKET, CELL_IH, 9)
+            CALL readbuffer(SOCKET, NAT)
+          ENDIF
+          ! broadcast to all nodes
+          CALL M_bcast_d(COMM,CELL_H,9)
+          CALL M_bcast_d(COMM,CELL_IH,9)
+          CALL M_bcast_i(COMM,NAT,1)
+          ! convert to vasp LATT_CUR%A & %B format & units conversion
+          DO NI=1,3
+            LATT_CUR%A(NI,1) = CELL_H(NI*3-2)*AUTOA
+            LATT_CUR%A(NI,2) = CELL_H(NI*3-1)*AUTOA
+            LATT_CUR%A(NI,3) = CELL_H(NI*3)*AUTOA
+          ENDDO
+          DO NI=1,3
+            LATT_CUR%B(NI,1) = CELL_IH(NI*3-2)/AUTOA
+            LATT_CUR%B(NI,2) = CELL_IH(NI*3-1)/AUTOA
+            LATT_CUR%B(NI,3) = CELL_IH(NI*3)/AUTOA
+          ENDDO
+          CALL LATTIC(LATT_CUR)
+          IF (COMM%NODE_ME == 1) THEN
+            WRITE(TIU0,*) " @ DRIVER MODE: Received lattice"
+            WRITE(TIU6,2333) ((LATT_CUR%A(I,J),I=1,3),(LATT_CUR%B(I,J),I=1,3),J=1,3)
+          ENDIF
+          ! receives positions
+          IF (COMM%NODE_ME == 1) CALL readbuffer(SOCKET, IPIATOMS, NAT*3)
+          CALL M_bcast_d(COMM,IPIATOMS,NAT*3) ! and broadcast them to all nodes
+          ! convert to vasp DYN%POSION format & units conversion
+          DO NI=1,NAT
+            DYN%POSION(1,NI) = IPIATOMS(NI*3-2)*AUTOA
+            DYN%POSION(2,NI) = IPIATOMS(NI*3-1)*AUTOA
+            DYN%POSION(3,NI) = IPIATOMS(NI*3)*AUTOA
+          ENDDO
+          CALL KARDIR(NAT,DYN%POSION,LATT_CUR%B)
+          CALL TOPRIM(NAT,DYN%POSION)
+          IF (COMM%NODE_ME == 1) write(TIU0,*) " @ DRIVER MODE: Received positions "
+          ! move on to the next DO ion
+          EXIT driver_loop
+        ELSE IF (IMSG == 3) THEN
+          ! communicates energy info back to i-pi
+          IF (COMM%NODE_ME == 1) THEN
+            WRITE(TIU0,*) " @ DRIVER MODE: Returning v,forces,stress "
+            IPIPOT = (TOTEN-E%EENTROPY/(2+NORDER))*EVTOHA
+            DO NI=1,NAT
+              IPIFORCES(NI*3-2) = TIFOR(1,NI)*FOCTOAU
+              IPIFORCES(NI*3-1) = TIFOR(2,NI)*FOCTOAU
+              IPIFORCES(NI*3) = TIFOR(3,NI)*FOCTOAU
+            ENDDO
+            DO NI=1,3
+              VIRIAL(NI*3-2) = TSIF(1,NI)*EVTOHA
+              VIRIAL(NI*3-1) = TSIF(2,NI)*EVTOHA
+              VIRIAL(NI*3) = TSIF(3,NI)*EVTOHA
+            ENDDO
+            CALL writebuffer(SOCKET,"FORCEREADY  ",MSGLEN)
+            CALL writebuffer(SOCKET,IPIPOT)
+            CALL writebuffer(SOCKET,NAT)
+            CALL writebuffer(SOCKET,IPIFORCES,3*NAT)
+            CALL writebuffer(SOCKET,VIRIAL,9)
+            ! i-pi can also receive an arbitrary string, we just send back zero characters.
+            CALL writebuffer(SOCKET,0)
+          ENDIF
+          HASDATA=.FALSE.
+        ELSE
+          INFO%LSTOP=.TRUE.
+          IF (COMM%NODE_ME == 1) WRITE(TIU0,*) "EXIT driver or unknow msg received"
+          EXIT driver_loop
+        ENDIF
+      ENDDO driver_loop
+#endif
+
+!=======================================================================
+! DYN%IBRION =
 ! 1  quasi-Newton algorithm
 ! 2  conjugate gradient
 ! 3  quickmin
@@ -4538,7 +4762,6 @@ ibrion: IF (DYN%IBRION==0) THEN
          ENDIF
          
          CALL CHGLOC(WDES%NB_TOT,KPOINTS%NKPTS,LPAR,T_INFO%NIONS,WDES%ISPIN,PAR,W%FERWE)
-         
          !  get and write partial / projected DOS ...
          
          !  some compilers require to remove this statment
diff -urpN src/makefile ../vasp.5.4.4/src/makefile
--- src/makefile	2017-04-20 17:03:58.000000000 +0800
+++ ../vasp.5.4.4/src/makefile	2022-04-03 15:28:23.188045993 +0800
@@ -145,7 +145,7 @@ vasp: $(OBJS) $(FFT3D) $(INC) main.o
 	$(FCL) -o vasp $(OBJS) main.o $(FFT3D) $(LLIB) $(LINK)
 
 sources:
-	rsync -u $(SRCDIR)/*.F $(SRCDIR)/*.inc .
+	rsync -u $(SRCDIR)/*.F $(SRCDIR)/*.inc $(SRCDIR)/*.f90 $(SRCDIR)/*.c .
 #	-rsync -u $(SRCDIR)/*.f .
 
 libs: $(LIB)
@@ -200,3 +200,5 @@ main.o : main$(SUFFIX)
 fft3dlib_f77.o: fft3dlib_f77$(SUFFIX)
 	$(F77) $(FFLAGS_F77) -c $*$(SUFFIX)
 
+sockets.o: sockets.c
+	$(CC_LIB) -c sockets.c
diff -urpN src/.objects ../vasp.5.4.4/src/.objects
--- src/.objects	2017-04-20 17:04:05.000000000 +0800
+++ ../vasp.5.4.4/src/.objects	2023-04-23 21:55:43.810898183 +0800
@@ -1,5 +1,7 @@
 SOURCE=\
 	c2f_interface.o \
+        sockets.o \
+        fsockets.o \
 	base.o \
 	profiling.o \
 	openmp.o \
@@ -175,7 +177,8 @@ SOURCE=\
 	dmft.o \
 	auger.o \
 	dmatrix.o \
-	elphon.o
+	elphon.o \
+        outham.o
 
 SOURCE_O1 = \
 	cl_shift.o \
@@ -193,6 +196,8 @@ SOURCE_IN= \
 
 SOURCE_GPU =  \
 	c2f_interface.o \
+        sockets.o \
+        fsockets.o \
 	cuda_interface.o \
 	base.o \
 	base_gpu.o \
@@ -374,4 +379,5 @@ SOURCE_GPU =  \
 	dmft.o \
 	auger.o \
 	dmatrix.o \
-	elphon.o
+	elphon.o \
+        outham.o
diff -urpN src/outham.F ../vasp.5.4.4/src/outham.F
--- src/outham.F	1970-01-01 08:00:00.000000000 +0800
+++ ../vasp.5.4.4/src/outham.F	2023-04-23 21:53:29.844724597 +0800
@@ -0,0 +1,667 @@
+#include "symbol.inc"
+
+  SUBROUTINE OUT_HAM(GRID, NONL_S_ORI, PP, WDES, LATT_CUR, T_INFO, INFO, SV, &
+                LMDIM, CDIJ, CQIJ, HAMILTONIAN, EFERMI, TOTEN, NSTEP_ori,DYN)
+    USE prec
+    USE mgrid
+    USE nonl
+    USE pseudo
+    USE wave
+    USE lattice
+    USE base
+    USE poscar
+    USE mpimy
+    USE fock
+    USE mymath
+    USE hamil_high
+
+    IMPLICIT NONE
+    ! input
+    TYPE (grid_3d) :: GRID
+    TYPE (nonl_struct) :: NONL_S_ORI
+    TYPE (potcar) :: PP(NONL_S_ORI%NTYP)
+    TYPE (wavedes) :: WDES
+    TYPE (latt) :: LATT_CUR
+    TYPE (type_info) :: T_INFO
+    TYPE (info_struct) :: INFO
+    RGRID :: SV(DIMREAL(GRID%MPLWV),WDES%NCDIJ)
+    INTEGER :: LMDIM
+    OVERLAP CDIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+    OVERLAP CQIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+    REAL(q) :: EFERMI
+    REAL(q) :: TOTEN
+
+    ! extra check
+    LOGICAL, EXTERNAL :: USEFOCK_CONTRIBUTION
+    TYPE (ham_handle) :: HAMILTONIAN
+
+    ! local
+    TYPE (nonl_struct) :: NONL_S
+    INTEGER :: ISP, NK, NT, LMMAXC, NIS,CH
+    INTEGER :: NPLWV, NPLMAX, NPL
+#ifdef debug
+    INTEGER, ALLOCATABLE :: G_INDEX(:,:),G_INDEX_LOC(:,:)
+#endif
+    INTEGER :: NP, NNP, ISPINOR
+    COMPLEX(q), ALLOCATABLE :: FHAM(:,:),CWORK(:)
+    REAL(q),ALLOCATABLE :: WAE_PS(:,:),WAE(:,:),WPS(:,:)
+
+    ! io
+    INTEGER :: IUHAM, i, j,CH0,CH1,CH2,CH3, i_in1, i_in2
+    CHARACTER(5) :: NKINDEX,NISP,NTINDEX,NB_C,INB_INDEX
+    CHARACTER(40) :: FORM
+
+    ! time
+    INTEGER :: t1,t2
+    
+    ! molecular dynamics
+    TYPE (dynamics)    DYN
+    INTEGER :: NSTEP_ori, NSTEP
+    CHARACTER(10) :: NSTEP_C
+    CHARACTER(40) :: MK_DIR
+    CHARACTER(200) :: MV
+    INTEGER :: NKPTS
+    
+    LOGICAL :: LINDEX    
+
+    LINDEX = INFO%LINDEX
+
+    ! Hybrid functional not supported
+    ! meta-GGA not supported
+    IF (USEFOCK_CONTRIBUTION()) THEN
+        WRITE(*,*) 'Hybrid functional not supported, quit'
+        CALL M_exit(); stop
+    ENDIF
+
+    IF (ASSOCIATED(HAMILTONIAN%MU)) THEN
+        WRITE(*,*) 'meta-GGA not supported, quit'
+        CALL M_exit(); stop
+    ENDIF
+
+    IF (WDES%LSPIRAL) THEN
+        WRITE(*,*) 'spinor not supported, quit'
+        CALL M_exit(); stop
+    ENDIF
+
+    ! make a copy for non_local structure
+    !NONL_S=NONL_S_ORI
+    !IF (INFO%LREAL) THEN
+        ! if projector function was calculated in real space
+        ! turn to reciprocal space now
+        CALL NONL_ALLOC(NONL_S, T_INFO, PP, WDES, .FALSE.)
+        CALL SPHER(GRID, NONL_S, PP, WDES, LATT_CUR,  1)
+        CALL PHASE(WDES,NONL_S,0)
+    !ENDIF
+
+    WRITE(NB_C,'(g0)') INFO%NB
+
+    NPLWV=GRID%NGX*GRID%NGY*GRID%NGZ
+    NPLMAX=maxval(WDES%NGVECTOR)
+
+    NSTEP=NSTEP_ori+INFO%NCONT
+    IF (MOD(NSTEP_ori+INFO%NCONT-1,INFO%NJUMP).EQ.0) THEN
+
+    IF (DYN%IBRION==0 .OR. DYN%IBRION==23) THEN
+        WRITE(NSTEP_C,'(g0)') NSTEP
+        MK_DIR='mkdir ./BEAD_'//TRIM(NSTEP_C)//' 1>/dev/null 2>&1'
+        CALL system( MK_DIR )
+    ENDIF
+
+    IF (MOD(0,WDES%COMM_KIN%NCPU) .NE. (WDES%COMM_KIN%NODE_ME-1)) THEN
+        GOTO 202
+    ENDIF
+
+    CALL system_clock(t1)
+    IF (INFO%NB>1 .OR. NSTEP>1) LINDEX=.FALSE.
+
+    IF (INFO%LKPOINTS) THEN
+        NKPTS = WDES%NKPTS
+    ELSE
+        NKPTS = 1
+    ENDIF
+
+
+      IF (MOD(0,WDES%COMM_KINTER%NCPU) .EQ. (WDES%COMM_KINTER%NODE_ME-1)) THEN
+          IF (LINDEX) THEN
+          IUHAM=540
+          OPEN(IUHAM,FILE='./VKPT',&
+                  STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',RECL=8)
+          DO NK=1,WDES%NKPTS
+            DO i=1,3
+              WRITE(IUHAM,REC=3*(NK-1)+i) WDES%VKPT(i,NK)
+            ENDDO
+          ENDDO
+          CLOSE(IUHAM)
+          ENDIF
+
+          IUHAM=540
+          OPEN(IUHAM,FILE='HEAD_'//TRIM(NB_C),&
+                  STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',RECL=8)
+          DO i=1,3
+          DO j=1,3
+            WRITE(IUHAM,REC=j+3*(i-1)) LATT_CUR%A(j,i)
+          ENDDO
+          ENDDO
+          WRITE(IUHAM,REC=10) EFERMI
+          WRITE(IUHAM,REC=11) TOTEN
+          CLOSE(IUHAM)
+          OPEN(IUHAM,FILE='HEAD_'//TRIM(NB_C),&
+                  STATUS='UNKNOWN',FORM='UNFORMATTED',ACCESS='DIRECT',RECL=4)
+          WRITE(IUHAM,REC=23) WDES%NKPTS
+          WRITE(IUHAM,REC=24) WDES%ISPIN
+          WRITE(IUHAM,REC=25) NONL_S%NTYP
+          DO i=1,NONL_S%NTYP
+            WRITE(IUHAM,REC=25+i) NONL_S%NITYP(i)
+          ENDDO
+          WRITE(IUHAM,REC=26+NONL_S%NTYP) WDES%COMM_INB%NCPU
+          CLOSE(IUHAM)
+ 
+          IF (DYN%IBRION==0 .OR. DYN%IBRION==23) THEN
+              MV='mv ./HEAD_'//TRIM(NB_C)//' ./BEAD_'//TRIM(NSTEP_C)//' 1>/dev/null 2>&1'
+              CALL system(MV)
+          ENDIF
+      ENDIF
+ 
+      ! index for calculated G-grids in the whole grid
+#ifdef debug
+      IF (LINDEX) THEN
+        ALLOCATE(G_INDEX(NPLMAX,WDES%NKPTS),G_INDEX_LOC(NPLWV,WDES%NKPTS))
+        CALL GEN_G_INDEX(G_INDEX,G_INDEX_LOC,NPLWV,NPLMAX,WDES,GRID)
+      ENDIF
+#endif
+ 
+      IF (MOD(0,WDES%COMM_KINTER%NCPU) .EQ. (WDES%COMM_KINTER%NODE_ME-1)) THEN
+          NIS=1
+          typ2:DO NT=1,NONL_S%NTYP
+            LMMAXC=NONL_S%LMMAX(NT)
+  
+            IF (LMMAXC.NE.0) THEN
+              WRITE(NTINDEX,'(g0)') NT
+              ! take a lot of space, write position instead.
+              ! phase
+              IUHAM=540
+              OPEN(IUHAM,FILE='POS_'//TRIM(NB_C)//'_'//TRIM(NTINDEX),&
+                      STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                      RECL=24*NONL_S%NITYP(NT))
+  
+              WRITE(IUHAM,REC=1) NONL_S%POSION(1:3,NIS:NIS+NONL_S%NITYP(NT)-1)
+  
+              CLOSE(IUHAM)
+  
+              ! information needed for transformation opertor T
+              ! radial grids and simpson coefficient
+              IF (LINDEX) THEN
+                  ! INDEX for lm 
+                  OPEN(IUHAM,FILE='LM_INDEX_'//TRIM(NB_C)//'_'//TRIM(NTINDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=4*PP(NT)%LMAX)
+                  WRITE(IUHAM,Rec=1) PP(NT)%LPS(1:PP(NT)%LMAX)
+         
+                  CLOSE(IUHAM)
+
+                  CALL SET_SIMP(PP(NT)%R)
+                  OPEN(IUHAM,FILE='SIMPI_'//TRIM(NB_C)//'_'//TRIM(NTINDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=8)
+                  WRITE(IUHAM,REC=1) PP(NT)%R%NMAX,NT
+               
+                  DO i=1,PP(NT)%R%NMAX
+                    WRITE(IUHAM,REC=i+1) PP(NT)%R%R(i)
+                  ENDDO
+               
+                  DO i=1,PP(NT)%R%NMAX
+                    WRITE(IUHAM,REC=i+PP(NT)%R%NMAX+1) PP(NT)%R%SI(i)
+                  ENDDO
+               
+                  CLOSE(IUHAM)
+               
+                  ALLOCATE(WAE_PS(PP(NT)%R%NMAX,PP(NT)%LMAX))
+                  DO CH=1,PP(NT)%LMAX
+                    WAE_PS(1:PP(NT)%R%NMAX,CH)=PP(NT)%R%R(1:PP(NT)%R%NMAX)*&
+                            (PP(NT)%WAE(1:PP(NT)%R%NMAX,CH)-&
+                            PP(NT)%WPS(1:PP(NT)%R%NMAX,CH))
+                  ENDDO
+               
+                  OPEN(IUHAM,FILE='PWAV_'//TRIM(NB_C)//'_'//TRIM(NTINDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=8*PP(NT)%LMAX*PP(NT)%R%NMAX)
+                  WRITE(IUHAM,REC=1) WAE_PS
+                  CLOSE(IUHAM)
+                  DEALLOCATE(WAE_PS)
+               
+                  ALLOCATE(WAE(PP(NT)%R%NMAX,PP(NT)%LMAX))
+                  DO CH=1,PP(NT)%LMAX
+                    WAE(1:PP(NT)%R%NMAX,CH)=&
+                            PP(NT)%WAE(1:PP(NT)%R%NMAX,CH)
+                  ENDDO
+               
+                  OPEN(IUHAM+1,FILE='WAE_'//TRIM(NB_C)//'_'//TRIM(NTINDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=8*PP(NT)%LMAX*PP(NT)%R%NMAX)
+                  WRITE(IUHAM+1,REC=1) WAE
+                  CLOSE(IUHAM+1)
+                  DEALLOCATE(WAE)
+  
+                  ALLOCATE(WPS(PP(NT)%R%NMAX,PP(NT)%LMAX))
+                  DO CH=1,PP(NT)%LMAX
+                    WPS(1:PP(NT)%R%NMAX,CH)=&
+                            PP(NT)%WPS(1:PP(NT)%R%NMAX,CH)
+                  ENDDO
+               
+                  OPEN(IUHAM+2,FILE='WPS_'//TRIM(NB_C)//'_'//TRIM(NTINDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=8*PP(NT)%LMAX*PP(NT)%R%NMAX)
+                  WRITE(IUHAM+2,REC=1) WPS
+                  CLOSE(IUHAM+2)
+                  DEALLOCATE(WPS)
+               
+                  ! Projector for interpolation 
+                  OPEN(IUHAM+3,FILE='PSPNL_'//TRIM(NB_C)//'_'//TRIM(NTINDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=8)
+                  WRITE(IUHAM+3,REC=1) PP(NT)%PSMAXN
+                  DO CH=1,PP(NT)%LDIM
+                    DO i=1,NPSNL+1
+                      WRITE(IUHAM+3,REC=i+(CH-1)*(NPSNL+1)+1) PP(NT)%PSPNL(i-1,CH)
+                    ENDDO
+                  ENDDO
+                  CLOSE(IUHAM+3)
+              ENDIF
+  
+            ENDIF
+            NIS=NIS+NONL_S%NITYP(NT)
+          ENDDO typ2
+ 
+          IF (DYN%IBRION==0 .OR. DYN%IBRION==23) THEN
+              MV='mv ./POS_'//TRIM(NB_C)//'_* ./SIMPI_'//TRIM(NB_C)//'_* ./PWAV_'//TRIM(NB_C)//'_* ./WAE_'//TRIM(NB_C)//'_* ./WPS_'//TRIM(NB_C)//'_* ./BEAD_'//TRIM(NSTEP_C)//' 1>/dev/null 2>&1'
+              CALL system(MV)
+          ENDIF
+      ENDIF
+ 
+ 
+      WRITE(INB_INDEX,'(g0)') WDES%COMM_INB%NODE_ME
+      spin: DO ISP=1,WDES%NCDIJ
+ 
+        IUHAM=540
+        WRITE(NISP,'(g0)') ISP
+        ! information needed for local potential and kinetic energy
+        IF (MOD(0,WDES%COMM_KINTER%NCPU) .EQ. (WDES%COMM_KINTER%NODE_ME-1)) THEN
+          IF (WDES%COMM_INB%NCPU.NE.1) THEN
+#ifdef realmode
+              OPEN(IUHAM,FILE='SV_'//TRIM(NB_C)//'_'//TRIM(NISP)//'_'//TRIM(INB_INDEX),&
+                      STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',RECL=8*GRID%RL%NP)
+#else
+              OPEN(IUHAM,FILE='SV_'//TRIM(NB_C)//'_'//TRIM(NISP)//'_'//TRIM(INB_INDEX),&
+                      STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',RECL=16*GRID%RL%NP)
+#endif
+          ELSE
+#ifdef realmode
+              OPEN(IUHAM,FILE='SV_'//TRIM(NB_C)//'_'//TRIM(NISP),&
+                      STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',RECL=8*GRID%RL%NP)
+#else
+              OPEN(IUHAM,FILE='SV_'//TRIM(NB_C)//'_'//TRIM(NISP),&
+                      STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',RECL=16*GRID%RL%NP)
+#endif
+          ENDIF
+          WRITE(IUHAM,REC=1) SV(1:GRID%RL%NP,ISP)
+          CLOSE(IUHAM)
+
+          NIS=1;i_in1=1;i_in2=1
+          typ1: DO NT=1,NONL_S%NTYP
+          LMMAXC=NONL_S%LMMAX(NT)
+     
+            IF (LMMAXC.NE.0) THEN
+              WRITE(NTINDEX,'(g0)') NT
+              ! nonlocal pseudopotential strength
+              IF (WDES%COMM_INB%NCPU.NE.1) THEN
+#ifdef realmode
+                  OPEN(IUHAM,FILE='./CDIJ_'//TRIM(NB_C)//'_'//&
+                          TRIM(NISP)//'_'//TRIM(NTINDEX)//'_'//TRIM(INB_INDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=8*LMMAXC)
+#else
+                  OPEN(IUHAM,FILE='./CDIJ_'//TRIM(NB_C)//'_'//&
+                          TRIM(NISP)//'_'//TRIM(NTINDEX)//'_'//TRIM(INB_INDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=16*LMMAXC)
+#endif
+              ELSE
+#ifdef realmode
+                  OPEN(IUHAM,FILE='./CDIJ_'//TRIM(NB_C)//'_'//&
+                          TRIM(NISP)//'_'//TRIM(NTINDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=8*LMMAXC)
+#else
+                  OPEN(IUHAM,FILE='./CDIJ_'//TRIM(NB_C)//'_'//&
+                          TRIM(NISP)//'_'//TRIM(NTINDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=16*LMMAXC)
+#endif
+              ENDIF
+              ! DO i=1,NONL_S%NITYP(NT)
+              DO i=NIS,NIS+NONL_S%NITYP(NT)-1
+                IF (NI_LOCAL(i,WDES%COMM_INB) /=0 ) THEN
+                  DO j=1,LMMAXC
+                    WRITE(IUHAM,Rec=(i-NIS)*LMMAXC+j) CDIJ(1:LMMAXC,j,i_in1,ISP)
+                  ENDDO
+                  i_in1=i_in1+1
+                ENDIF
+              ENDDO
+     
+              CLOSE(IUHAM)
+     
+              ! overlap strength
+              IF (WDES%COMM_INB%NCPU.NE.1) THEN
+#ifdef realmode
+                  OPEN(IUHAM,FILE='./CQIJ_'//TRIM(NB_C)//'_'//&
+                          TRIM(NISP)//'_'//TRIM(NTINDEX)//'_'//TRIM(INB_INDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=8*LMMAXC)
+#else
+                  OPEN(IUHAM,FILE='./CQIJ_'//TRIM(NB_C)//'_'//&
+                          TRIM(NISP)//'_'//TRIM(NTINDEX)//'_'//TRIM(INB_INDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=16*LMMAXC)
+#endif
+              ELSE
+#ifdef realmode
+                  OPEN(IUHAM,FILE='./CQIJ_'//TRIM(NB_C)//'_'//&
+                          TRIM(NISP)//'_'//TRIM(NTINDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=8*LMMAXC)
+#else
+                  OPEN(IUHAM,FILE='./CQIJ_'//TRIM(NB_C)//'_'//&
+                          TRIM(NISP)//'_'//TRIM(NTINDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=16*LMMAXC)
+#endif
+              ENDIF
+              ! DO i=1,NONL_S%NITYP(NT)
+              DO i=NIS,NIS+NONL_S%NITYP(NT)-1
+                IF (NI_LOCAL(i,WDES%COMM_INB) /=0 ) THEN
+                  DO j=1,LMMAXC
+                    WRITE(IUHAM,Rec=(i-NIS)*LMMAXC+j) CQIJ(1:LMMAXC,j,i_in2,ISP)
+                  ENDDO
+                  i_in2=i_in2+1
+                ENDIF
+              ENDDO
+     
+              CLOSE(IUHAM)
+              NIS=NIS+NONL_S%NITYP(NT)
+            ENDIF
+          ENDDO typ1
+        ENDIF
+ 
+        kpoint: DO NK=1,NKPTS
+          ! used to allocate kpoints to different nodes
+          IF (MOD(NK-1,WDES%COMM_KINTER%NCPU) .NE. (WDES%COMM_KINTER%NODE_ME-1)) &
+                  CYCLE kpoint
+        ! kpoint: DO NK=1,1
+
+          CALL PHASE(WDES,NONL_S,NK)
+          NPL=WDES%NGVECTOR(NK)
+
+          ! io information
+          IUHAM=540
+          WRITE(NKINDEX,'(g0)') NK
+
+#ifdef debug
+          ! used for checking
+          ALLOCATE(FHAM(NPL,NPL),CWORK(NPL*WDES%NRSPINORS))
+          DO NP=1, NPL
+              CALL CAC_FHAM_LOCAL(SV(1,ISP),CWORK,NP,GRID,NPL,NK,&
+                      WDES%NINDPW(1,NK),WDES,G_INDEX_LOC(1,NK))
+              DO NNP=1, NPL
+              DO ISPINOR=0,WDES%NRSPINORS-1
+                  FHAM(NNP,NP)=FHAM(NNP,NP)+CWORK(NNP+NPL*ISPINOR)
+              ENDDO
+              ENDDO
+          ENDDO
+ 
+          OPEN(IUHAM,FILE='LOC_'//TRIM(NB_C)//'_'//TRIM(NKINDEX)//'_'//TRIM(NISP),&
+                  STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',RECL=16*NPL*NPL)
+          WRITE(IUHAM,REC=1) FHAM
+          CLOSE(IUHAM)
+          DEALLOCATE(FHAM,CWORK)
+#endif
+
+          ! Since it's the same for all configuartions, only output once
+          IF (LINDEX) THEN
+              ! index for calculated G-grids in the whole grid
+              OPEN(IUHAM,FILE='INDEX_'//TRIM(NB_C)//'_'//TRIM(NKINDEX)//'_'//TRIM(NISP),&
+                      STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',RECL=16)
+              WRITE(IUHAM,REC=1) GRID%NGX,GRID%NGY,GRID%NGZ,NPL
+            
+#ifdef debug
+              DO i=1,NPL
+                WRITE(IUHAM,REC=i+1) WDES%IGX(i,NK),WDES%IGY(i,NK),WDES%IGZ(i,NK),G_INDEX(i,NK)
+              ENDDO
+            
+              WRITE(IUHAM,REC=NPL+2) WDES%VKPT(1,NK),WDES%VKPT(2,NK)
+              WRITE(IUHAM,REC=NPL+3) WDES%VKPT(3,NK),0._q
+#endif
+            
+              CLOSE(IUHAM)
+         
+              ! information needed for non local potential
+              NIS=1
+              typ:DO NT=1,NONL_S%NTYP
+                LMMAXC=NONL_S%LMMAX(NT)
+           
+                IF (LMMAXC.NE.0) THEN
+                  WRITE(NTINDEX,'(g0)') NT
+#ifdef wrtphase
+                  ! take a lot of space, write position instead.
+                  ! phase
+                  OPEN(IUHAM,FILE='PHASE_'//TRIM(NB_C)//'_'//TRIM(NKINDEX)//'_'//&
+                          TRIM(NISP)//'_'//TRIM(NTINDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=16*NPL*NONL_S%NITYP(NT))
+           
+                  WRITE(IUHAM,REC=1) NONL_S%CREXP(1:NPL,&
+                          NIS:NIS+NONL_S%NITYP(NT)-1)
+           
+                  CLOSE(IUHAM)
+#endif
+                  ! projection function
+                  OPEN(IUHAM,FILE='PROJ_'//TRIM(NB_C)//'_'//TRIM(NKINDEX)//'_'//&
+                          TRIM(NISP)//'_'//TRIM(NTINDEX),&
+                          STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                          RECL=8)
+                  WRITE(IUHAM,Rec=1) PP(NT)%LMAX,LMMAXC
+                  CH0=0;CH1=0;CH2=0;CH3=0;
+                  DO i=1,PP(NT)%LMAX
+                    IF (PP(NT)%LPS(i)==0) THEN
+                      CH0=CH0+1
+                    ELSEIF (PP(NT)%LPS(i)==1) THEN
+                      CH1=CH1+1
+                    ELSEIF (PP(NT)%LPS(i)==2) THEN
+                      CH2=CH2+1
+                    ELSEIF (PP(NT)%LPS(i)==3) THEN
+                      CH3=CH3+1
+                    ELSE
+                      WRITE(*,*) 'warning:L>3 not supported now'
+                    ENDIF
+                  ENDDO
+                  WRITE(IUHAM,Rec=2) 0,CH0
+                  WRITE(IUHAM,Rec=3) 1,CH1
+                  WRITE(IUHAM,Rec=4) 2,CH2
+                  WRITE(IUHAM,Rec=5) 3,CH3
+                 
+                  DO i=1,LMMAXC
+                    DO j=1,NPL
+                      WRITE(IUHAM,Rec=j+5+(i-1)*NPL) NONL_S%QPROJ(j,i,NT,NK,1)
+                    ENDDO
+                  ENDDO
+              
+                  ! not used
+                  IF (WDES%LSPIRAL) THEN
+                    DO i=LMMAXC+1,2*LMMAXC
+                      DO j=1,NPL
+                        WRITE(IUHAM,Rec=j+5+(i-1)*NPL) NONL_S%QPROJ(1:NPL,i,NT,NK,2)
+                      ENDDO
+                    ENDDO
+                  ENDIF
+         
+                  CLOSE(IUHAM)
+         
+         
+                ENDIF
+                NIS=NIS+NONL_S%NITYP(NT)
+              ENDDO typ
+          ENDIF
+ 
+          IF (DYN%IBRION==0 .OR. DYN%IBRION==23) THEN
+              MV='mv ./INDEX_'//TRIM(NB_C)//'_'//TRIM(NKINDEX)//'_* ./PROJ_'//TRIM(NB_C)//'_'//TRIM(NKINDEX)//'_* ./CDIJ_'//TRIM(NB_C)//'_'//TRIM(NKINDEX)//'_* ./CQIJ_'//TRIM(NB_C)//'_'//TRIM(NKINDEX)//'_* ./BEAD_'//TRIM(NSTEP_C)//' 1>/dev/null 2>&1'
+              CALL system(MV)
+          ENDIF
+ 
+        ENDDO kpoint
+ 
+      ENDDO spin
+
+      IF (DYN%IBRION==0 .OR. DYN%IBRION==23) THEN
+          MV='mv ./SV_'//TRIM(NB_C)//'_* ./BEAD_'//TRIM(NSTEP_C)//' 1>/dev/null 2>&1'
+          CALL system(MV)
+      ENDIF
+     
+      CALL system_clock(t2)
+      IF (MOD(0,WDES%COMM_KINTER%NCPU) .EQ. (WDES%COMM_KINTER%NODE_ME-1)) THEN
+        WRITE(*,*) ''
+        WRITE(*,*) 'OUTPUT OVER:',(t2-t1)/10._q,'ms'
+      ENDIF
+     
+#ifdef debug
+      IF (LINDEX) THEN
+        DEALLOCATE(G_INDEX,G_INDEX_LOC)
+      ENDIF
+#endif
+
+  202 IF (MOD(0,WDES%COMM_INTER%NCPU) .EQ. (WDES%COMM_INTER%NODE_ME-1)) THEN
+          IF (MOD(0,WDES%COMM_INB%NCPU) .NE. (WDES%COMM_INB%NODE_ME-1)) THEN
+            spin2: DO ISP=1,WDES%NCDIJ
+  
+              IUHAM=540+WDES%NKPTS*ISP
+              WRITE(NISP,'(g0)') ISP
+              WRITE(INB_INDEX,'(g0)') WDES%COMM_INB%NODE_ME
+              ! information needed for local potential and kinetic energy
+              IF (MOD(0,WDES%COMM_KINTER%NCPU) .EQ. (WDES%COMM_KINTER%NODE_ME-1)) THEN
+#ifdef realmode
+                OPEN(IUHAM,FILE='./SV_'//TRIM(NB_C)//'_'//TRIM(NISP)//'_'//TRIM(INB_INDEX),&
+                        STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',RECL=8*GRID%RL%NP)
+#else
+                OPEN(IUHAM,FILE='./SV_'//TRIM(NB_C)//'_'//TRIM(NISP)//'_'//TRIM(INB_INDEX),&
+                        STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',RECL=16*GRID%RL%NP)
+#endif
+                WRITE(IUHAM,REC=1) SV(1:GRID%RL%NP,ISP)
+                CLOSE(IUHAM)
+
+                NIS=1;i_in1=1;i_in2=1
+                typ3: DO NT=1,NONL_S%NTYP
+                LMMAXC=NONL_S%LMMAX(NT)
+           
+                  IF (LMMAXC.NE.0) THEN
+                    WRITE(NTINDEX,'(g0)') NT
+                    ! nonlocal pseudopotential strength
+#ifdef realmode
+                    OPEN(IUHAM,FILE='./CDIJ_'//TRIM(NB_C)//'_'//&
+                            TRIM(NISP)//'_'//TRIM(NTINDEX)//'_'//TRIM(INB_INDEX),&
+                            STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                            RECL=8*LMMAXC)
+#else
+                    OPEN(IUHAM,FILE='./CDIJ_'//TRIM(NB_C)//'_'//&
+                            TRIM(NISP)//'_'//TRIM(NTINDEX)//'_'//TRIM(INB_INDEX),&
+                            STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                            RECL=16*LMMAXC)
+#endif
+                    ! DO i=1,NONL_S%NITYP(NT)
+                    DO i=NIS,NIS+NONL_S%NITYP(NT)-1
+                      IF (NI_LOCAL(i,WDES%COMM_INB) /=0 ) THEN
+                        DO j=1,LMMAXC
+                          WRITE(IUHAM,Rec=(i-NIS)*LMMAXC+j) CDIJ(1:LMMAXC,j,i_in1,ISP)
+                        ENDDO
+                        i_in1=i_in1+1
+                      ENDIF
+                    ENDDO
+           
+                    CLOSE(IUHAM)
+           
+                    ! overlap strength
+#ifdef realmode
+                    OPEN(IUHAM,FILE='./CQIJ_'//TRIM(NB_C)//'_'//&
+                            TRIM(NISP)//'_'//TRIM(NTINDEX)//'_'//TRIM(INB_INDEX),&
+                            STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                            RECL=8*LMMAXC)
+#else
+                    OPEN(IUHAM,FILE='./CQIJ_'//TRIM(NB_C)//'_'//&
+                            TRIM(NISP)//'_'//TRIM(NTINDEX)//'_'//TRIM(INB_INDEX),&
+                            STATUS='REPLACE',FORM='UNFORMATTED',ACCESS='DIRECT',&
+                            RECL=16*LMMAXC)
+#endif
+                    ! DO i=1,NONL_S%NITYP(NT)
+                    DO i=NIS,NIS+NONL_S%NITYP(NT)-1
+                      IF (NI_LOCAL(i,WDES%COMM_INB) /=0 ) THEN
+                        DO j=1,LMMAXC
+                          WRITE(IUHAM,Rec=(i-NIS)*LMMAXC+j) CQIJ(1:LMMAXC,j,i_in2,ISP)
+                        ENDDO
+                        i_in2=i_in2+1
+                      ENDIF
+                    ENDDO
+           
+                    CLOSE(IUHAM)
+                    NIS=NIS+NONL_S%NITYP(NT)
+                  ENDIF
+                ENDDO typ3
+              ENDIF
+            ENDDO spin2
+
+
+          ENDIF
+
+      ENDIF
+
+      ENDIF
+      CALL NONL_DEALLOC(NONL_S)
+    
+      IF (INFO%LCLOSE) THEN
+        STOP
+      ENDIF
+  END SUBROUTINE
+
+  SUBROUTINE GEN_G_INDEX(G_INDEX, G_INDEX_LOC, NPLWV, NPLMAX, WDES, GRID)
+    USE prec
+    USE mgrid
+    USE wave
+
+    IMPLICIT NONE
+    TYPE (wavedes) :: WDES
+    TYPE (grid_3d) :: GRID
+    INTEGER :: NPLWV, NPLMAX
+    INTEGER :: G_INDEX(NPLMAX,WDES%NKPTS)
+    INTEGER :: G_INDEX_LOC(NPLWV,WDES%NKPTS)
+
+    INTEGER :: NK, IND, NG
+
+    G_INDEX=0
+    G_INDEX_LOC=0
+    
+    kpoint:DO NK=1,WDES%NKPTS
+        ! used to allocate kpoints to different nodes
+        IF (MOD(NK-1,WDES%COMM_KINTER%NCPU) .NE. (WDES%COMM_KINTER%NODE_ME-1)) &
+                CYCLE kpoint
+
+        ! give the relationship in position between G points and grid points
+        !OPEN(UNIT=2000,FILE='G_INDEX',STATUS='UNKNOWN')
+        !REWIND 2000
+        DO IND=1, WDES%NGVECTOR(NK)
+            NG= MOD(WDES%IGX(IND,NK)+GRID%NGX,GRID%NGX)+1 +&
+                    MOD(WDES%IGY(IND,NK)+GRID%NGY,GRID%NGY)*GRID%NGX_rd + &
+                    MOD(WDES%IGZ(IND,NK)+GRID%NGZ,GRID%NGZ)*GRID%NGY*GRID%NGX_rd
+            G_INDEX(IND,NK)=NG
+            G_INDEX_LOC(NG,NK)=IND
+            !WRITE(2000,*) IND,WDES%IGX(IND,NK),WDES%IGY(IND,NK),WDES%IGZ(IND,NK),NG
+        ENDDO
+        !CLOSE(2000)
+    ENDDO kpoint
+
+  END SUBROUTINE
diff -urpN src/pot_gpu.F ../vasp.5.4.4/src/pot_gpu.F
--- src/pot_gpu.F	2017-04-20 17:03:59.000000000 +0800
+++ ../vasp.5.4.4/src/pot_gpu.F	2022-04-03 15:27:25.939345923 +0800
@@ -22,6 +22,9 @@
 #ifdef CUDA_GPU
       USE cuda_interface
 #endif
+! bexternal__
+      USE bexternal
+! bexternal__
 
       IMPLICIT COMPLEX(q) (C)
       IMPLICIT REAL(q) (A-B,D-H,O-Z)
@@ -253,6 +256,9 @@ nv_profile_start(NVP_POTLOK_LPPOT)
       DO I=1,GRIDC%RC%NP
          CVTOT(I,1)=CVTOT(I,1)+CWORK(I,1)
       ENDDO
+! bexternal__
+      IF (LBEXTERNAL()) CALL BEXT_ADDV(CVTOT,GRIDC,SIZE(CVTOT,2))
+! bexternal__
       CALL POT_FLIP(CVTOT, GRIDC,WDES%NCDIJ )
 nv_profile_stop(NVP_POTLOK_LPPOT)
 !=======================================================================
diff -urpN src/reader.F ../vasp.5.4.4/src/reader.F
--- src/reader.F	2017-04-20 17:03:59.000000000 +0800
+++ ../vasp.5.4.4/src/reader.F	2022-09-18 10:50:44.796656303 +0800
@@ -19,7 +19,11 @@
      &        LNONCOLLINEAR,LSORBIT,SAXIS,LMETAGGA, &
      &        LSPIRAL,LZEROZ,QSPIRAL,LORBITALREAL, &
      &        LASPH,TURBO,IRESTART,NREBOOT,NMIN,EREF, &
-     &        NLSPLINE,ISPECIAL,MDALGO &
+     &        NLSPLINE,ISPECIAL,MDALGO, &
+     &        LFIXCOM, &
+     &        LFHAM,NCUT,NTEST,LSMAL,KOMEGA,TEMP, &
+     &        NB,LINDEX,LSTOP,NCONT,LKPOINTS,NJUMP &
+     &       ,IHOST,PORT,INET &
 #ifdef libbeef
      &       ,LBEEFENS,LBEEFBAS &
 #endif
@@ -69,6 +73,9 @@
       LOGICAL   NLSPLINE
       INTEGER   ISPECIAL
       INTEGER   MDALGO 
+! ipi port, socket type, host
+      INTEGER   PORT, INET
+      CHARACTER(1024) IHOST
 !-MM- Spin spiral stuff      
       LOGICAL   LSPIRAL,LZEROZ
       REAL(q)   QSPIRAL(3)
@@ -593,6 +600,7 @@
 ! number of ionic steps, calculate stresses? (default NSW=0, ISIF=2):
       NSW=0
       IF (IBRION==5 .OR. IBRION==6 .OR. IBRION==7 .OR. IBRION==8) NSW=1
+      IF (IBRION==23) NSW=100000 ! default large steps for ipi driver
       CALL RDATAB(LOPEN,INCAR,IU5,'NSW','=','#',';','I', &
      &            NSW,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
       IF (((IERR/=0).AND.(IERR/=3)).OR. &
@@ -607,6 +615,8 @@
       ISIF=2
       ! if MD is selected dont calculate stress
       IF (IBRION==0) ISIF=0
+      ! ipi driver mode default calculate stress and allow cell to change
+      IF (IBRION==23) ISIF=3
       CALL RDATAB(LOPEN,INCAR,IU5,'ISIF','=','#',';','I', &
      &            ISIF,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
       IF (((IERR/=0).AND.(IERR/=3)).OR. &
@@ -627,6 +637,8 @@
 #endif
 ! relaxation: IWAVPR=1
       IF (IBRION>0) IWAVPR=1
+! ipi driver mode default wavefunction extrapolation same as relaxation
+      IF (IBRION==23) IWAVPR=1
       CALL RDATAB(LOPEN,INCAR,IU5,'IWAVPR','=','#',';','I', &
      &            IWAVPR,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
       IF (((IERR/=0).AND.(IERR/=3)).OR. &
@@ -647,9 +659,45 @@
       IWAVPR=MOD(IWAVPR,10)+10
 #endif
       CALL XML_INCAR('IWAVPR','I',IWAVPR,RDUM,CDUM,LDUM,CHARAC,N)
+      
+! read ipi host & port 
+      IF (IBRION==23) THEN
+        SZNAM='localhost'
+        CALL RDATAB(LOPEN,INCAR,IU5,'IHOST','=','#',';','S', &
+        &            IDUM,RDUM,CDUM,LDUM,SZNAM,N,256,IERR)
+        IF ((IERR/=0).AND.(IERR/=3)) THEN
+            IF (IU0>=0) &
+            WRITE(IU0,*)'Error reading item ''IHOST'' from file INCAR.'
+            GOTO 150
+        ENDIF
+        CALL STRIP(SZNAM,N,'A')
+        IHOST=SZNAM
+        CALL XML_INCAR('IHOST','S',IDUM,RDUM,CDUM,LDUM,SZNAM,N)
+        PORT=23333
+        CALL RDATAB(LOPEN,INCAR,IU5,'PORT','=','#',';','I', &
+        &            PORT,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+        IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+            WRITE(IU0,*)'Error reading item ''PORT'' from file INCAR.'
+            GOTO 150
+        ENDIF
+        CALL XML_INCAR('PORT','I',PORT,RDUM,CDUM,LDUM,CHARAC,N)
+        INET=1
+        CALL RDATAB(LOPEN,INCAR,IU5,'INET','=','#',';','I', &
+        &            INET,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+        IF (((IERR/=0).AND.(IERR/=3)).OR. &
+        &                    ((IERR==0).AND.(N<1))) THEN
+            IF (IU0>=0) &
+            WRITE(IU0,*)'Error reading item ''INET'' from file INCAR.'
+            GOTO 150
+        ENDIF
+        CALL XML_INCAR('INET','I',INET,RDUM,CDUM,LDUM,CHARAC,N)
+      ENDIF
 
 ! switch on symmetry (default ISYM=1):
       ISYM=1 ; IF (LPAW) ISYM=2
+      IF (IBRION==23) ISYM=0 ! default no symm for ipi driver mode
       CALL RDATAB(LOPEN,INCAR,IU5,'ISYM','=','#',';','I', &
      &            ISYM,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
       IF (((IERR/=0).AND.(IERR/=3)).OR. &
@@ -1729,6 +1777,154 @@
       CALL XML_INCAR('MDALGO','I',MDALGO,RDUM,CDUM,LDUM,CHARAC,N)
       IF (MDALGO<0) MDALGO=0
 
+! --------------------------------------------------------------------
+      ! Fix the center of mass (for Langevin thermo.)
+      LFIXCOM=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LFIXCOM','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LFIXCOM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LFIXCOM'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LFIXCOM','L',IDUM,RDUM,CDUM,LFIXCOM,CHARAC,N)
+! --------------------------------------------------------------------
+! LFHAM -- obtain the full Hamilton Matrix
+      LFHAM=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LFHAM','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LFHAM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LFHAM'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LFHAM','L',IDUM,RDUM,CDUM,LFHAM,CHARAC,N)
+
+      LSMAL=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LSMAL','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LSMAL,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LSMAL'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LSMAL','L',IDUM,RDUM,CDUM,LSMAL,CHARAC,N)
+
+      NCUT=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'NCUT','=','#',';','I', &
+     &            NCUT,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NCUT'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NCUT','I',NCUT,RDUM,CDUM,LDUM,CHARAC,N)
+
+      NTEST=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'NTEST','=','#',';','I', &
+     &            NTEST,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NTEST'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NTEST','I',NTEST,RDUM,CDUM,LDUM,CHARAC,N)
+
+      KOMEGA=16
+      CALL RDATAB(LOPEN,INCAR,IU5,'KOMEGA','=','#',';','I', &
+     &            KOMEGA,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''KOMEGA'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('KOMEGA','I',KOMEGA,RDUM,CDUM,LDUM,CHARAC,N)
+
+      TEMP=350._q
+      CALL RDATAB(LOPEN,INCAR,IU5,'TEMP','=','#',';','I', &
+     &            IDUM,TEMP,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''TEMP'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('TEMP','F',IDUM,TEMP,CDUM,LDUM,CHARAC,N)
+
+      NB=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'NB','=','#',';','I', &
+     &            NB,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NB'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NB','I',NB,RDUM,CDUM,LDUM,CHARAC,N)
+
+      LINDEX=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LINDEX','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LINDEX,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LINDEX'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LINDEX','L',IDUM,RDUM,CDUM,LINDEX,CHARAC,N)
+
+      LCLOSE=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LCLOSE','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LCLOSE,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LCLOSE'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LCLOSE','L',IDUM,RDUM,CDUM,LSTOP,CHARAC,N)
+
+      NCONT=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'NCONT','=','#',';','I', &
+     &            NCONT,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NCONT'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NCONT','I',NCONT,RDUM,CDUM,LDUM,CHARAC,N)
+
+      LKPOINTS=.FALSE.
+      CALL RDATAB(LOPEN,INCAR,IU5,'LKPOINTS','=','#',';','L', &
+     &            IDUM,RDUM,CDUM,LKPOINTS,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''LKPOINTS'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('LKPOINTS','L',IDUM,RDUM,CDUM,LKPOINTS,CHARAC,N)
+
+      NJUMP=1
+      CALL RDATAB(LOPEN,INCAR,IU5,'NJUMP','=','#',';','I', &
+     &            NJUMP,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''NJUMP'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      CALL XML_INCAR('NJUMP','I',NJUMP,RDUM,CDUM,LDUM,CHARAC,N)
+! --------------------------------------------------------------------
+! --------------------------------------------------------------------
+
 #ifdef libbeef
 ! read in flag LBEEFENS 
       LBEEFENS=.FALSE.
diff -urpN src/sockets.c ../vasp.5.4.4/src/sockets.c
--- src/sockets.c	1970-01-01 08:00:00.000000000 +0800
+++ ../vasp.5.4.4/src/sockets.c	2022-04-03 15:28:23.188045993 +0800
@@ -0,0 +1,155 @@
+/* A minimal wrapper for socket communication.
+
+Copyright (C) 2013, Joshua More and Michele Ceriotti
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+Contains both the functions that transmit data to the socket and read the data
+back out again once finished, and the function which opens the socket initially.
+Can be linked to a FORTRAN code that does not support sockets natively.
+
+Functions:
+   error: Prints an error message and then exits.
+   open_socket_: Opens a socket with the required host server, socket type and
+      port number.
+   write_buffer_: Writes a string to the socket.
+   read_buffer_: Reads data from the socket.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <sys/un.h>
+#include <netdb.h>
+
+void open_socket(int *psockfd, int* inet, int* port, const char* host)
+/* Opens a socket.
+
+Note that fortran passes an extra argument for the string length, but this is
+ignored here for C compatibility.
+
+Args:
+   psockfd: The id of the socket that will be created.
+   inet: An integer that determines whether the socket will be an inet or unix
+      domain socket. Gives unix if 0, inet otherwise.
+   port: The port number for the socket to be created. Low numbers are often
+      reserved for important channels, so use of numbers of 4 or more digits is
+      recommended.
+   host: The name of the host server.
+*/
+
+{
+   int sockfd, ai_err;
+
+   if (*inet>0)
+   {  // creates an internet socket
+      
+      // fetches information on the host      
+      struct addrinfo hints, *res;  
+      char service[256];
+   
+      memset(&hints, 0, sizeof(hints));
+      hints.ai_socktype = SOCK_STREAM;
+      hints.ai_family = AF_INET;
+      hints.ai_flags = AI_PASSIVE;
+
+      sprintf(service,"%d",*port); // convert the port number to a string
+      ai_err = getaddrinfo(host, service, &hints, &res); 
+      if (ai_err!=0) { perror("Error fetching host data. Wrong host name?"); exit(-1); }
+
+      // creates socket
+      sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+      if (sockfd < 0) { perror("Error opening socket"); exit(-1); }
+    
+      // makes connection
+      if (connect(sockfd, res->ai_addr, res->ai_addrlen) < 0) 
+      { perror("Error opening INET socket: wrong port or server unreachable"); exit(-1); }
+      freeaddrinfo(res);
+   }
+   else
+   {  
+      struct sockaddr_un serv_addr;
+
+      // fills up details of the socket addres
+      memset(&serv_addr, 0, sizeof(serv_addr));
+      serv_addr.sun_family = AF_UNIX;
+      strcpy(serv_addr.sun_path, "/tmp/ipi_");
+      strcpy(serv_addr.sun_path+9, host);
+      // creates a unix socket
+  
+      // creates the socket
+      sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
+
+      // connects
+      if (connect(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) 
+      { perror("Error opening UNIX socket: path unavailable, or already existing"); exit(-1); }
+   }
+
+
+   *psockfd=sockfd;
+}
+
+void writebuffer(int *psockfd, const char *data, int* plen)
+/* Writes to a socket.
+
+Args:
+   psockfd: The id of the socket that will be written to.
+   data: The data to be written to the socket.
+   plen: The length of the data in bytes.
+*/
+
+{
+   int n;
+   int sockfd=*psockfd;
+   int len=*plen;
+
+   n = write(sockfd,data,len);
+   if (n < 0) { perror("Error writing to socket: server has quit or connection broke"); exit(-1); }
+}
+
+
+void readbuffer(int *psockfd, char *data, int* plen)
+/* Reads from a socket.
+
+Args:
+   psockfd: The id of the socket that will be read from.
+   data: The storage array for data read from the socket.
+   plen: The length of the data in bytes.
+*/
+
+{
+   int n, nr;
+   int sockfd=*psockfd;
+   int len=*plen;
+
+   n = nr = read(sockfd,data,len);
+
+   while (nr>0 && n<len )
+   {  nr=read(sockfd,&data[n],len-n); n+=nr; }
+
+   if (n == 0) { perror("Error reading from socket: server has quit or connection broke"); exit(-1); }
+}
+
+
diff -urpN src/sphpro.F ../vasp.5.4.4/src/sphpro.F
--- src/sphpro.F	2017-04-20 17:03:59.000000000 +0800
+++ ../vasp.5.4.4/src/sphpro.F	2022-04-03 15:27:25.955346119 +0800
@@ -600,7 +600,8 @@
       ENDIF
 #ifndef realmode
 ! Orbital moment: start
-      DO ISP=1,WDES%NCDIJ
+      !DO ISP=1,WDES%NCDIJ
+      DO ISP=1,WDES%ISPIN
          DO IDIR=1,3
             PARAUG_lmom(LL+1,NI,IDIR,ISP)=PARAUG_lmom(LL+1,NI,IDIR,ISP)+SUM(REAL(CSUM_ABS_lmom(:,IDIR,ISP),q))
          ENDDO
